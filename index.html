<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Real-Time Gesture &amp; Expression Recognition</title>
  <style>
    :root {
      --bg-color: #0f172a;
      --panel-color: #1e293b;
      --accent-color: #38bdf8;
      --accent-strong: #0ea5e9;
      --text-color: #e2e8f0;
      --muted-color: #94a3b8;
      --positive-color: #4ade80;
      --negative-color: #f87171;
      --shadow-color: rgba(15, 23, 42, 0.55);
    }

    [data-theme="light"] {
      --bg-color: #f8fafc;
      --panel-color: #ffffff;
      --accent-color: #2563eb;
      --accent-strong: #1d4ed8;
      --text-color: #0f172a;
      --muted-color: #475569;
      --positive-color: #16a34a;
      --negative-color: #dc2626;
      --shadow-color: rgba(15, 23, 42, 0.14);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      background: radial-gradient(circle at top, rgba(14, 165, 233, 0.12), transparent 45%), var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.5rem 2rem 1rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.5rem, 2.4vw, 2.75rem);
      display: flex;
      align-items: center;
      gap: 0.65rem;
      letter-spacing: 0.02em;
    }

    header h1 span.logo {
      width: 42px;
      height: 42px;
      border-radius: 14px;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, rgba(14, 165, 233, 0.6), rgba(59, 130, 246, 0.85));
      box-shadow: 0 12px 30px rgba(14, 165, 233, 0.45);
    }

    header .actions {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.35rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.3s ease;
      color: #fff;
    }

    button.primary {
      background: linear-gradient(135deg, var(--accent-color), var(--accent-strong));
      box-shadow: 0 12px 25px rgba(37, 99, 235, 0.35);
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.18);
      color: var(--text-color);
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }

    main {
      flex: 1;
      display: grid;
      gap: 1.5rem;
      padding: 0 2rem 2rem;
      grid-template-columns: minmax(0, 1.2fr) minmax(300px, 0.8fr);
    }

    .panel {
      background: var(--panel-color);
      border-radius: 22px;
      box-shadow: 0 25px 50px var(--shadow-color);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .video-panel {
      padding: 1.25rem;
      gap: 1rem;
    }

    .video-wrapper {
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      background: rgba(148, 163, 184, 0.12);
      display: grid;
      place-items: center;
    }

    video {
      width: 100%;
      display: block;
      border-radius: inherit;
    }

    .status-strip {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      background: rgba(56, 189, 248, 0.14);
      border-radius: 14px;
      padding: 0.85rem 1rem;
      border: 1px solid rgba(56, 189, 248, 0.28);
      backdrop-filter: blur(12px);
      margin-top: 1rem;
    }

    .status-strip strong {
      font-size: 0.95rem;
      letter-spacing: 0.02em;
    }

    .status-strip span.dot {
      display: inline-flex;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, var(--accent-color), rgba(56, 189, 248, 0.45));
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.85);
    }

    .results-panel {
      padding: 1.5rem;
      gap: 1.25rem;
    }

    .results-panel h2 {
      margin: 0 0 0.75rem;
      font-size: 1.1rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted-color);
    }

    .detection-card {
      background: rgba(15, 23, 42, 0.35);
      border-radius: 18px;
      padding: 1.25rem;
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 1.1rem;
      align-items: center;
    }

    [data-theme="light"] .detection-card {
      background: rgba(148, 163, 184, 0.12);
    }

    .detection-emoji {
      font-size: 3rem;
      display: grid;
      place-items: center;
    }

    .detection-details h3 {
      margin: 0;
      font-size: 1.3rem;
    }

    .confidence-label {
      font-size: 0.9rem;
      color: var(--muted-color);
      margin-top: 0.35rem;
    }

    .confidence-label.low {
      color: var(--negative-color);
    }

    .history-list {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      max-height: 220px;
      overflow: auto;
      padding-right: 0.2rem;
    }

    .history-item {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 0.65rem;
      align-items: center;
      background: rgba(148, 163, 184, 0.12);
      padding: 0.65rem 0.85rem;
      border-radius: 12px;
    }

    .history-item span {
      white-space: nowrap;
    }

    .placeholder {
      color: var(--muted-color);
      font-size: 0.9rem;
      text-align: center;
      padding: 2rem 1rem;
      border-radius: 16px;
      background: rgba(148, 163, 184, 0.08);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
    }

    .stat {
      background: rgba(148, 163, 184, 0.12);
      border-radius: 14px;
      padding: 0.85rem 1rem;
      display: grid;
      gap: 0.35rem;
    }

    .stat strong {
      font-size: 1.4rem;
    }

    label.slider-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      font-size: 0.9rem;
      color: var(--muted-color);
    }

    input[type="range"] {
      flex: 1;
      accent-color: var(--accent-color);
    }

    footer {
      text-align: center;
      padding: 1rem 2rem 2rem;
      font-size: 0.85rem;
      color: var(--muted-color);
    }

    @media (max-width: 1024px) {
      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1><span class="logo">ðŸ¤–</span>Gesture &amp; Expression Monitor</h1>
    <div class="actions">
      <label class="slider-label">
        Sensitivity
        <input id="sensitivity" type="range" min="0.4" max="0.95" step="0.01" value="0.7" />
      </label>
      <button id="theme-toggle" class="secondary" type="button">Toggle Theme</button>
      <button id="start-btn" class="primary" type="button">Start Camera</button>
    </div>
  </header>
  <main>
    <section class="panel video-panel">
      <div class="video-wrapper">
        <video id="camera" autoplay playsinline muted></video>
      </div>
      <div class="status-strip">
        <strong id="status-text">Camera idle â€” click Start to begin.</strong>
        <div class="status-meta">
          <span class="dot"></span>
          <span id="latency-text">Latency â€”</span>
        </div>
      </div>
    </section>
    <section class="panel results-panel">
      <div>
        <h2>Current Detection</h2>
        <div class="detection-card">
          <div class="detection-emoji" id="detection-emoji">ðŸ§ </div>
          <div class="detection-details">
            <h3 id="detection-title">Awaiting inputâ€¦</h3>
            <p id="detection-description">Enable the camera and keep gestures or expressions centered within the frame.</p>
            <div class="confidence-label" id="detection-confidence"></div>
          </div>
        </div>
      </div>
      <div>
        <h2>Detection History</h2>
        <div class="history-list" id="history-list"></div>
      </div>
      <div>
        <h2>Session Statistics</h2>
        <div class="stats-grid">
          <div class="stat">
            <span>Hand Gestures</span>
            <strong id="gesture-count">0</strong>
          </div>
          <div class="stat">
            <span>Facial Expressions</span>
            <strong id="expression-count">0</strong>
          </div>
          <div class="stat">
            <span>Avg. Confidence</span>
            <strong id="avg-confidence">â€”</strong>
          </div>
        </div>
      </div>
    </section>
  </main>
  <footer>
    Processing happens on the server â€” frames are securely analyzed with MediaPipe and returned with gesture &amp; expression matches.
  </footer>
  <script>
    const startBtn = document.getElementById('start-btn');
    const themeToggle = document.getElementById('theme-toggle');
    const videoEl = document.getElementById('camera');
    const statusText = document.getElementById('status-text');
    const latencyText = document.getElementById('latency-text');
    const detectionEmoji = document.getElementById('detection-emoji');
    const detectionTitle = document.getElementById('detection-title');
    const detectionDescription = document.getElementById('detection-description');
    const detectionConfidence = document.getElementById('detection-confidence');
    const historyList = document.getElementById('history-list');
    const gestureCountEl = document.getElementById('gesture-count');
    const expressionCountEl = document.getElementById('expression-count');
    const avgConfidenceEl = document.getElementById('avg-confidence');
    const sensitivityInput = document.getElementById('sensitivity');

    const captureCanvas = document.createElement('canvas');
    const captureCtx = captureCanvas.getContext('2d');

    let stream = null;
    let capturing = false;
    let inFlight = false;
    let lastCapture = 0;
    const CAPTURE_INTERVAL = 120; // ms

    const sessionId = (typeof crypto !== 'undefined' && crypto.randomUUID)
      ? crypto.randomUUID()
      : `${Date.now()}-${Math.random().toString(16).slice(2)}`;

    let statusError = false;

    function setStatus(message, isError = false) {
      statusText.textContent = message;
      statusText.style.color = isError ? 'var(--negative-color)' : 'inherit';
      statusError = isError;
    }

    function renderPlaceholderHistory() {
      historyList.innerHTML = '';
      const placeholder = document.createElement('div');
      placeholder.className = 'placeholder';
      placeholder.textContent = 'No detections yet â€” show a gesture or facial expression to begin the log.';
      historyList.appendChild(placeholder);
    }

    renderPlaceholderHistory();

    function updatePrimary(primary) {
      if (!primary) {
        detectionEmoji.textContent = 'ðŸ§ ';
        detectionTitle.textContent = 'Scanningâ€¦';
        detectionDescription.textContent = 'Hold steady in front of the camera to allow the server to evaluate your pose.';
        detectionConfidence.textContent = '';
        detectionConfidence.classList.remove('low');
        return;
      }

      detectionEmoji.textContent = primary.emoji;
      detectionTitle.textContent = primary.label;
      detectionDescription.textContent = primary.description;
      if (typeof primary.confidence === 'number') {
        detectionConfidence.textContent = `Confidence ${(primary.confidence * 100).toFixed(0)}%`;
        detectionConfidence.classList.toggle('low', primary.confidence < 0.75);
      } else {
        detectionConfidence.textContent = '';
        detectionConfidence.classList.remove('low');
      }
    }

    function updateHistory(history) {
      historyList.innerHTML = '';
      if (!history || !history.length) {
        renderPlaceholderHistory();
        return;
      }

      history.forEach(entry => {
        const item = document.createElement('div');
        item.className = 'history-item';

        const emoji = document.createElement('span');
        emoji.textContent = entry.emoji;

        const label = document.createElement('div');
        const time = new Date(entry.timestamp);
        label.innerHTML = `<strong>${entry.label}</strong><br><small>${entry.type === 'gesture' ? 'Hand' : 'Face'} â€¢ ${time.toLocaleTimeString()}</small>`;

        const conf = document.createElement('span');
        conf.textContent = typeof entry.confidence === 'number'
          ? `${Math.round(entry.confidence * 100)}%`
          : 'â€”';

        item.append(emoji, label, conf);
        historyList.appendChild(item);
      });
    }

    function updateStats(stats) {
      if (!stats) {
        gestureCountEl.textContent = '0';
        expressionCountEl.textContent = '0';
        avgConfidenceEl.textContent = 'â€”';
        return;
      }
      gestureCountEl.textContent = stats.gesture ?? 0;
      expressionCountEl.textContent = stats.expression ?? 0;
      avgConfidenceEl.textContent = typeof stats.average_confidence === 'number'
        ? `${Math.round(stats.average_confidence * 100)}%`
        : 'â€”';
    }

    async function sendFrame() {
      if (!capturing || !stream) {
        return;
      }

      if (videoEl.readyState < 2) {
        requestAnimationFrame(captureLoop);
        return;
      }

      captureCanvas.width = videoEl.videoWidth;
      captureCanvas.height = videoEl.videoHeight;
      captureCtx.drawImage(videoEl, 0, 0, captureCanvas.width, captureCanvas.height);
      const dataUrl = captureCanvas.toDataURL('image/jpeg', 0.75);

      inFlight = true;
      const payload = {
        session_id: sessionId,
        image: dataUrl,
        sensitivity: parseFloat(sensitivityInput.value)
      };

      try {
        const response = await fetch('/api/detect', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error(`Server responded with ${response.status}`);
        }

        const result = await response.json();
        updatePrimary(result.primary_detection ?? null);
        updateHistory(result.history ?? []);
        updateStats(result.stats ?? null);
        if (statusError) {
          setStatus('Streaming to server â€” hold steady for recognition.');
        }
        if (typeof result.latency_ms === 'number') {
          latencyText.textContent = `Latency ${result.latency_ms.toFixed(0)} ms`;
        }
      } catch (error) {
        console.error(error);
        setStatus('Detection server unavailable. Retryingâ€¦', true);
      } finally {
        inFlight = false;
        requestAnimationFrame(captureLoop);
      }
    }

    async function captureLoop(timestamp) {
      if (!capturing) {
        return;
      }

      if (inFlight) {
        requestAnimationFrame(captureLoop);
        return;
      }

      if (timestamp - lastCapture < CAPTURE_INTERVAL) {
        requestAnimationFrame(captureLoop);
        return;
      }

      lastCapture = timestamp;
      await sendFrame();
    }

    async function startCamera() {
      if (capturing) {
        return;
      }

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setStatus('Camera API unavailable in this browser.', true);
        return;
      }

      try {
        setStatus('Requesting camera accessâ€¦');
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        videoEl.srcObject = stream;
        await videoEl.play();
        capturing = true;
        startBtn.disabled = true;
        setStatus('Streaming to server â€” hold steady for recognition.');
        requestAnimationFrame(captureLoop);
      } catch (error) {
        console.error(error);
        setStatus('Unable to access the camera. Check permissions and try again.', true);
      }
    }

    startBtn.addEventListener('click', startCamera);

    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.getAttribute('data-theme');
      const next = current === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
    });

    document.addEventListener('visibilitychange', () => {
      if (document.hidden && capturing) {
        capturing = false;
        startBtn.disabled = false;
        setStatus('Paused â€” click Start to resume.');
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
          stream = null;
        }
      }
    });
  </script>
</body>
</html>
